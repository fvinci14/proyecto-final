import { Component, EventEmitter, Input, Output } from "@angular/core";
import { NgxMatTimepickerUnits } from "../../models/ngx-mat-timepicker-units.enum";
import { NgxMatTimepickerUtils } from "../../utils/ngx-mat-timepicker.utils";
import { NgxMatTimepickerFaceComponent } from "../ngx-mat-timepicker-face/ngx-mat-timepicker-face.component";
import * as i0 from "@angular/core";
export class NgxMatTimepickerMinutesFaceComponent {
    set color(newValue) {
        this._color = newValue;
    }
    get color() {
        return this._color;
    }
    constructor() {
        this.minuteChange = new EventEmitter();
        this.minutesList = [];
        this.timeUnit = NgxMatTimepickerUnits;
        this._color = "primary";
    }
    ngOnChanges(changes) {
        // tslint:disable-next-line:no-string-literal
        if (changes["period"] && changes["period"].currentValue) {
            const minutes = NgxMatTimepickerUtils.getMinutes(this.minutesGap);
            this.minutesList = NgxMatTimepickerUtils.disableMinutes(minutes, this.selectedHour, {
                min: this.minTime,
                max: this.maxTime,
                format: this.format,
                period: this.period
            });
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.1", ngImport: i0, type: NgxMatTimepickerMinutesFaceComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.0.1", type: NgxMatTimepickerMinutesFaceComponent, isStandalone: true, selector: "ngx-mat-timepicker-minutes-face", inputs: { color: "color", format: "format", maxTime: "maxTime", minTime: "minTime", minutesGap: "minutesGap", period: "period", selectedHour: "selectedHour", selectedMinute: "selectedMinute" }, outputs: { minuteChange: "minuteChange" }, usesOnChanges: true, ngImport: i0, template: "<ngx-mat-timepicker-face [color]=\"color\"\r\n                     [faceTime]=\"minutesList\"\r\n                     [selectedTime]=\"selectedMinute\"\r\n                     [minutesGap]=\"minutesGap\"\r\n                     (timeChange)=\"minuteChange.next($event)\"\r\n                     [unit]=\"timeUnit.MINUTE\"></ngx-mat-timepicker-face>\r\n", dependencies: [{ kind: "component", type: NgxMatTimepickerFaceComponent, selector: "ngx-mat-timepicker-face", inputs: ["color", "faceTime", "format", "minutesGap", "selectedTime", "unit"], outputs: ["timeChange", "timeSelected"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.1", ngImport: i0, type: NgxMatTimepickerMinutesFaceComponent, decorators: [{
            type: Component,
            args: [{ selector: "ngx-mat-timepicker-minutes-face", standalone: true, imports: [NgxMatTimepickerFaceComponent], template: "<ngx-mat-timepicker-face [color]=\"color\"\r\n                     [faceTime]=\"minutesList\"\r\n                     [selectedTime]=\"selectedMinute\"\r\n                     [minutesGap]=\"minutesGap\"\r\n                     (timeChange)=\"minuteChange.next($event)\"\r\n                     [unit]=\"timeUnit.MINUTE\"></ngx-mat-timepicker-face>\r\n" }]
        }], ctorParameters: () => [], propDecorators: { color: [{
                type: Input
            }], format: [{
                type: Input
            }], maxTime: [{
                type: Input
            }], minTime: [{
                type: Input
            }], minuteChange: [{
                type: Output
            }], minutesGap: [{
                type: Input
            }], period: [{
                type: Input
            }], selectedHour: [{
                type: Input
            }], selectedMinute: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LW1hdC10aW1lcGlja2VyLW1pbnV0ZXMtZmFjZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtbWF0LXRpbWVwaWNrZXIvc3JjL2xpYi9jb21wb25lbnRzL25neC1tYXQtdGltZXBpY2tlci1taW51dGVzLWZhY2Uvbmd4LW1hdC10aW1lcGlja2VyLW1pbnV0ZXMtZmFjZS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtbWF0LXRpbWVwaWNrZXIvc3JjL2xpYi9jb21wb25lbnRzL25neC1tYXQtdGltZXBpY2tlci1taW51dGVzLWZhY2Uvbmd4LW1hdC10aW1lcGlja2VyLW1pbnV0ZXMtZmFjZS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsU0FBUyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQWEsTUFBTSxFQUFnQixNQUFNLGVBQWUsQ0FBQztBQUsvRixPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSw0Q0FBNEMsQ0FBQztBQUVqRixPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSxzQ0FBc0MsQ0FBQztBQUMzRSxPQUFPLEVBQUUsNkJBQTZCLEVBQUUsTUFBTSw4REFBOEQsQ0FBQzs7QUFVN0csTUFBTSxPQUFPLG9DQUFvQztJQUU3QyxJQUNJLEtBQUssQ0FBQyxRQUFzQjtRQUM1QixJQUFJLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQztJQUMzQixDQUFDO0lBRUQsSUFBSSxLQUFLO1FBQ0wsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3ZCLENBQUM7SUFrQkQ7UUFaVSxpQkFBWSxHQUFHLElBQUksWUFBWSxFQUE2QixDQUFDO1FBR3ZFLGdCQUFXLEdBQWdDLEVBQUUsQ0FBQztRQUs5QyxhQUFRLEdBQUcscUJBQXFCLENBQUM7UUFFekIsV0FBTSxHQUFpQixTQUFTLENBQUM7SUFHekMsQ0FBQztJQUVELFdBQVcsQ0FBQyxPQUFzQjtRQUM5Qiw2Q0FBNkM7UUFDN0MsSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLFlBQVksRUFBRTtZQUNyRCxNQUFNLE9BQU8sR0FBRyxxQkFBcUIsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ2xFLElBQUksQ0FBQyxXQUFXLEdBQUcscUJBQXFCLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsWUFBWSxFQUFFO2dCQUNoRixHQUFHLEVBQUUsSUFBSSxDQUFDLE9BQU87Z0JBQ2pCLEdBQUcsRUFBRSxJQUFJLENBQUMsT0FBTztnQkFDakIsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO2dCQUNuQixNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07YUFDdEIsQ0FBQyxDQUFDO1NBQ047SUFDTCxDQUFDOzhHQXpDUSxvQ0FBb0M7a0dBQXBDLG9DQUFvQyw2VkNsQmpELGtXQU1BLDRDRFVjLDZCQUE2Qjs7MkZBRTlCLG9DQUFvQztrQkFOaEQsU0FBUzsrQkFDSSxpQ0FBaUMsY0FFL0IsSUFBSSxXQUNQLENBQUMsNkJBQTZCLENBQUM7d0RBS3BDLEtBQUs7c0JBRFIsS0FBSztnQkFTRyxNQUFNO3NCQUFkLEtBQUs7Z0JBQ0csT0FBTztzQkFBZixLQUFLO2dCQUNHLE9BQU87c0JBQWYsS0FBSztnQkFFSSxZQUFZO3NCQUFyQixNQUFNO2dCQUNFLFVBQVU7c0JBQWxCLEtBQUs7Z0JBR0csTUFBTTtzQkFBZCxLQUFLO2dCQUNHLFlBQVk7c0JBQXBCLEtBQUs7Z0JBRUcsY0FBYztzQkFBdEIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkNoYW5nZXMsIE91dHB1dCwgU2ltcGxlQ2hhbmdlc30gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcclxuaW1wb3J0IHtUaGVtZVBhbGV0dGV9IGZyb20gXCJAYW5ndWxhci9tYXRlcmlhbC9jb3JlXCI7XHJcbi8vXHJcbmltcG9ydCB7Tmd4TWF0VGltZXBpY2tlckNsb2NrRmFjZX0gZnJvbSBcIi4uLy4uL21vZGVscy9uZ3gtbWF0LXRpbWVwaWNrZXItY2xvY2stZmFjZS5pbnRlcmZhY2VcIjtcclxuaW1wb3J0IHtOZ3hNYXRUaW1lcGlja2VyRm9ybWF0VHlwZX0gZnJvbSBcIi4uLy4uL21vZGVscy9uZ3gtbWF0LXRpbWVwaWNrZXItZm9ybWF0LnR5cGVcIjtcclxuaW1wb3J0IHtOZ3hNYXRUaW1lcGlja2VyVW5pdHN9IGZyb20gXCIuLi8uLi9tb2RlbHMvbmd4LW1hdC10aW1lcGlja2VyLXVuaXRzLmVudW1cIjtcclxuaW1wb3J0IHtOZ3hNYXRUaW1lcGlja2VyUGVyaW9kc30gZnJvbSBcIi4uLy4uL21vZGVscy9uZ3gtbWF0LXRpbWVwaWNrZXItcGVyaW9kcy5lbnVtXCI7XHJcbmltcG9ydCB7Tmd4TWF0VGltZXBpY2tlclV0aWxzfSBmcm9tIFwiLi4vLi4vdXRpbHMvbmd4LW1hdC10aW1lcGlja2VyLnV0aWxzXCI7XHJcbmltcG9ydCB7IE5neE1hdFRpbWVwaWNrZXJGYWNlQ29tcG9uZW50IH0gZnJvbSBcIi4uL25neC1tYXQtdGltZXBpY2tlci1mYWNlL25neC1tYXQtdGltZXBpY2tlci1mYWNlLmNvbXBvbmVudFwiO1xyXG4vL1xyXG5pbXBvcnQge0RhdGVUaW1lfSBmcm9tIFwidHMtbHV4b25cIjtcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6IFwibmd4LW1hdC10aW1lcGlja2VyLW1pbnV0ZXMtZmFjZVwiLFxyXG4gICAgdGVtcGxhdGVVcmw6IFwiLi9uZ3gtbWF0LXRpbWVwaWNrZXItbWludXRlcy1mYWNlLmNvbXBvbmVudC5odG1sXCIsXHJcbiAgICBzdGFuZGFsb25lOiB0cnVlLFxyXG4gICAgaW1wb3J0czogW05neE1hdFRpbWVwaWNrZXJGYWNlQ29tcG9uZW50XVxyXG59KVxyXG5leHBvcnQgY2xhc3MgTmd4TWF0VGltZXBpY2tlck1pbnV0ZXNGYWNlQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcclxuXHJcbiAgICBASW5wdXQoKVxyXG4gICAgc2V0IGNvbG9yKG5ld1ZhbHVlOiBUaGVtZVBhbGV0dGUpIHtcclxuICAgICAgICB0aGlzLl9jb2xvciA9IG5ld1ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBjb2xvcigpOiBUaGVtZVBhbGV0dGUge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvcjtcclxuICAgIH1cclxuXHJcbiAgICBASW5wdXQoKSBmb3JtYXQ6IE5neE1hdFRpbWVwaWNrZXJGb3JtYXRUeXBlO1xyXG4gICAgQElucHV0KCkgbWF4VGltZTogRGF0ZVRpbWU7XHJcbiAgICBASW5wdXQoKSBtaW5UaW1lOiBEYXRlVGltZTtcclxuXHJcbiAgICBAT3V0cHV0KCkgbWludXRlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxOZ3hNYXRUaW1lcGlja2VyQ2xvY2tGYWNlPigpO1xyXG4gICAgQElucHV0KCkgbWludXRlc0dhcDogbnVtYmVyO1xyXG5cclxuICAgIG1pbnV0ZXNMaXN0OiBOZ3hNYXRUaW1lcGlja2VyQ2xvY2tGYWNlW10gPSBbXTtcclxuICAgIEBJbnB1dCgpIHBlcmlvZDogTmd4TWF0VGltZXBpY2tlclBlcmlvZHM7XHJcbiAgICBASW5wdXQoKSBzZWxlY3RlZEhvdXI6IG51bWJlcjtcclxuXHJcbiAgICBASW5wdXQoKSBzZWxlY3RlZE1pbnV0ZTogTmd4TWF0VGltZXBpY2tlckNsb2NrRmFjZTtcclxuICAgIHRpbWVVbml0ID0gTmd4TWF0VGltZXBpY2tlclVuaXRzO1xyXG5cclxuICAgIHByaXZhdGUgX2NvbG9yOiBUaGVtZVBhbGV0dGUgPSBcInByaW1hcnlcIjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIH1cclxuXHJcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXN0cmluZy1saXRlcmFsXHJcbiAgICAgICAgaWYgKGNoYW5nZXNbXCJwZXJpb2RcIl0gJiYgY2hhbmdlc1tcInBlcmlvZFwiXS5jdXJyZW50VmFsdWUpIHtcclxuICAgICAgICAgICAgY29uc3QgbWludXRlcyA9IE5neE1hdFRpbWVwaWNrZXJVdGlscy5nZXRNaW51dGVzKHRoaXMubWludXRlc0dhcCk7XHJcbiAgICAgICAgICAgIHRoaXMubWludXRlc0xpc3QgPSBOZ3hNYXRUaW1lcGlja2VyVXRpbHMuZGlzYWJsZU1pbnV0ZXMobWludXRlcywgdGhpcy5zZWxlY3RlZEhvdXIsIHtcclxuICAgICAgICAgICAgICAgIG1pbjogdGhpcy5taW5UaW1lLFxyXG4gICAgICAgICAgICAgICAgbWF4OiB0aGlzLm1heFRpbWUsXHJcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IHRoaXMuZm9ybWF0LFxyXG4gICAgICAgICAgICAgICAgcGVyaW9kOiB0aGlzLnBlcmlvZFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbiIsIjxuZ3gtbWF0LXRpbWVwaWNrZXItZmFjZSBbY29sb3JdPVwiY29sb3JcIlxyXG4gICAgICAgICAgICAgICAgICAgICBbZmFjZVRpbWVdPVwibWludXRlc0xpc3RcIlxyXG4gICAgICAgICAgICAgICAgICAgICBbc2VsZWN0ZWRUaW1lXT1cInNlbGVjdGVkTWludXRlXCJcclxuICAgICAgICAgICAgICAgICAgICAgW21pbnV0ZXNHYXBdPVwibWludXRlc0dhcFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICh0aW1lQ2hhbmdlKT1cIm1pbnV0ZUNoYW5nZS5uZXh0KCRldmVudClcIlxyXG4gICAgICAgICAgICAgICAgICAgICBbdW5pdF09XCJ0aW1lVW5pdC5NSU5VVEVcIj48L25neC1tYXQtdGltZXBpY2tlci1mYWNlPlxyXG4iXX0=